use std::str::FromStr;

grammar;

match {
    "<",
    ">",
    "(",
    ")",
    "{",
    "}",
    "|",
    ":",
    ",",
    ";",
    ".",
    "..",
    ":=",
    "::=",
    "puts",
    "case",
    "let",
    "in",
    r"\p{Ll}(\pL|[0-9_-])*",
    r"\p{Lu}(\pL|[0-9_-])*",
    r"[0-9]+",
    r"'([^'\\]|\\.)*'",
    r"\s*" => {},
    r"\(\*([^*]|\*[^)])*\*\)" => {},
}

use crate::ast::*;

pub Stmts: Vec<Stmt> = {
    <mut stmts:(<Stmt> ";")*> <stmt:Stmt?> => match stmt {
        None => stmts,
        Some(stmt) => {
            stmts.push(stmt);
            stmts
        }
    },
};

pub Stmt: Stmt = {
    "puts" <Expr> => Stmt::Puts(<>),
    <Name> ":=" <Expr> => Stmt::Assn(<>),
    <name:Name> "::=" <strs:(<Name>)*> => Stmt::LitAssn(name, strs),
};

pub Name: String = {
    r"\p{Ll}(\pL|[0-9_-])*" => <>.to_owned(),
};

pub Expr: Expr = {
    <mut ts:(<Choice> "|")*> <t:Choice> => {
        ts.push(t);
        Expr::Chc(ts)
    }
};

pub Choice: Choice = {
    <weight:Num> ":" <value:Term> => Choice {
        weight: Some(weight),
        value
    },
    <value:Term> => Choice {
        weight: None,
        value
    }
};

pub Term: Expr = {
    (<Branch>)* => Expr::Cat(<>),
};

pub Branch: Expr = {
    <l:Branch> "." <r:Subbranch> => Expr::Ap(Box::new(l), Box::new(r)),
    <Subbranch> => <>,
};

pub Subbranch: Expr = {
    <l:Subbranch> ".." <r:Leaf> => Expr::Range(Box::new(l), Box::new(r)),
    <Leaf> => <>,
}

pub Leaf: Expr = {
    <Literal> => Expr::Lit(<>),
    <Name> => Expr::Var(<>),
    "<" <mut es:(<Expr> ",")*> <e:Expr> ">" => {
        es.push(e);
        Expr::Tup(es)
    },
    "let" <name:Name> ":=" <e1:Expr> "{" <e2:Expr> "}" =>
        Expr::Let(name, Box::new(e1), Box::new(e2)),
    "(" <e:Expr> ")" => e,
};

pub Num: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap(),
};

pub Literal: Literal = {
    <Num> => Literal::Num(<>),
    r"'([^'\\]|\\.)*'" => Literal::from_str_literal(<>),
    r"\p{Lu}(\pL|[0-9_-])*" => Literal::Atom(<>.to_owned()),
};
